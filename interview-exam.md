1. 下面这段代码能否通过编译，如果可以，输出什么？

```
    func main() {
        s1 := []int{1, 2, 3}
        s2 := []int{4, 5}
        s1 = append(s1, s2)
        fmt.Println(s1)
    }

```
参考答案及解析：不能通过编译。append() 的第二个参数不能直接使用 slice，需使用 … 操作符，  将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。
> append(s1,s2...)  or append(s1,1,2,3)

2. 下面代码输出什么，请说明。
```
func main() {
    x := []int{0, 1, 2}
    y := [3]*int{}
    for i, v := range x {
        defer func() {
            print(v)
        }()
        y[i] = &v
    }
    print(*y[0], *y[1], *y[2])
}
```  


参考答案及解析：22222。  
知识点：defer()、for-range。for-range 虽然使用的是 :=，但是 v 不会重新声明，可以打印 v 的地址验证下。  
**在for range中，变量v是用来保存迭代切片所得的值，因为v只被声明了一次，每次迭代的值都是赋值给v，该变量的内存地址始终未变，这样讲他的地址追加到新的切片中，该切片保存的都是同一个地址。**  
变量v的地址也并不是指向原来切片的，因我**在使用range迭代的时候，变量v的数据是切片的拷贝数据，所以直接copy了结构体数据**。
或者 `y=append(y,&x[i])` **赋值修改**要在 切片具体值 例如 `y[i].age=18`
